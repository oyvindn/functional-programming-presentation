<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="http://gnab.github.com/remark/downloads/remark-0.4.6.min.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Functional Programming Idioms

---

# Agenda

 ----

* Functional Programming

* Idioms

  * Closures

  * Currying

  * Options

  * List comprehensions

---

<!-- Into: Functional Programming -->

# Functional Programming
 ---
- **Only** *pure functions*

- **No** *side effects*

- *Referential transparency*

---
<!-- Closures -->

# Closures

 ----
---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.
---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x // free variables: x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x // free variables: x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

- Closure ~= Closed

---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

- Flere eksempler:

```SML

  fun allGreaterThan (xs,n) =  filter (fn x => x > n, xs)

  allGreaterThan([1,2,3,4,5], 3) // 4, 5

```
---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

- Flere eksempler:

```SML

  fun allGreaterThan (xs,n) =  filter (fn x => x > n, xs)

  allGreaterThan([1,2,3,4,5], 3) // 4, 5

```

```SML

  fun numberInRange (xs,lo,hi) =
    fold ((fn (x,y) => x + (if y >= lo andalso y &#60;= hi then 1 else 0)),
           0,
           xs)

  numberInRange([1,2,3,4,5], 2, 4) // 2, 3, 4

```

---

<!-- Options -->

# Option
 ---

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

- I Scala er Option implementert som en parameterisert type : Option[A]

```scala
	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]
```

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

- I Scala er Option implementert som en parameterisert type : Option[A]

```scala
	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]
```

- Option kan sees på som en liste som kan holde på maksimalt ett element, og som har mye av den samme funksjonaliteten som en liste.

  - map, flatMap, filter, exists, foreach, head, tail, isEmpty, osv...

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

- I Scala er Option implementert som en parameterisert type : Option[A]

```scala
	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]
```

- Option kan sees på som en liste som kan holde på maksimalt ett element, og som har mye av den samme funksjonaliteten som en liste.

  - map, flatMap, filter, exists, foreach, head, tail, isEmpty, osv...

---

# Option
 ---
- Den mest idiomatiske måten å benytte en Option er å behandle den som en collection eller monad, og bruke map, flatMap, filter eller foreach.

```scala
	val avdeling: String =
		ansatteliste.get("Øyvind Nerbråten")
			.map(_.avdeling)
			.filter(_ != "BMC")
			.getOrElse("BEKK")
```

---

# Option
 ---
- Den mest idiomatiske måten å benytte en Option er å behandle den som en collection eller monad, og bruke map, flatMap, filter eller foreach.

```scala
	val avdeling: String =
		ansatteliste.get("Øyvind Nerbråten")
			.map(_.avdeling)
			.filter(_ != "BMC")
			.getOrElse("BEKK")
```

- Støtter også eksplisitt pattern matching

```scala
	val minAvdeling: Option[String] = 
		ansatteliste.get("Øyvind Nerbråten").map(_.avdeling) match {
			case Some("BMC") => "Bekk Management Consulting"
			case Some(x) => x
			case None => "BEKK"
		}
	
```

---

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>