<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="http://gnab.github.com/remark/downloads/remark-0.4.6.min.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Functional Programming Idioms

---

# Agenda

 ----

* Functional Programming

* Idioms

  * Closures

  * Options

  * Currying

  * List comprehensions

---

<!-- Into: Functional Programming -->

# Functional Programming
 ---
- **Only** *pure functions*

- **No** *side effects*

- *Referential transparency*

---



<!-- Closures -->

# Closures

 ----
---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.
---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x // free variables: x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

---

# Closures

 ----

- Består av:
    - First class function
    - Environment (Tabell av frie variabler)

- Lexical scope: Innholdet til en funksjon evalueres i miljøet der funksjonen ble definert. Ikke der funksjonen kalles.



```SML

  val x = 1
  fun add y = y + x // free variables: x

  val x = 2
  val y = 3

  val z = add(x+y)  // 2 + 3 + 1 = 6

```

- Closure ~= Closed

---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

- Flere eksempler:

```SML

  fun allGreaterThan (xs,n) =  filter (fn x => x > n, xs)

  allGreaterThan([1,2,3,4,5], 3) // 4, 5

```
---

# Closures

 ----

- Brukes overalt. (map, filter, reduce, osv...)

- Flere eksempler:

```SML

  fun allGreaterThan (xs,n) =  filter (fn x => x > n, xs)

  allGreaterThan([1,2,3,4,5], 3) // 4, 5

```

```SML

  fun numberInRange (xs,lo,hi) =
    fold ((fn (x,y) => x + (if y >= lo andalso y &#60;= hi then 1 else 0)),
           0,
           xs)

  numberInRange([1,2,3,4,5], 2, 4) // 3

```

---



<!-- Option -->

# Option
 ---

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

- I Scala er Option implementert som en parameterisert type : Option[A]

```scala
	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]
```

---

# Option
 ---
- Feilhåndtering uten bruk av exceptions

- I Scala er Option implementert som en parameterisert type : Option[A]

```scala
	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]
```

- Option kan sees på som en liste som kan holde på maksimalt ett element, og som har mye av den samme funksjonaliteten som en liste.

  - map, flatMap, filter, exists, foreach, head, tail, isEmpty, osv...

---

# Option
 ---
- Den mest idiomatiske måten å benytte en Option er å behandle den som en collection eller monad, og bruke map, flatMap, filter eller foreach.

```scala
	val avdeling: String =
		ansatteliste.get("Øyvind Nerbråten")
			.map(_.avdeling)
			.filter(_ != "BMC")
			.getOrElse("BEKK")
```

---

# Option
 ---
- Den mest idiomatiske måten å benytte en Option er å behandle den som en collection eller monad, og bruke map, flatMap, filter eller foreach.

```scala
	val avdeling: String =
		ansatteliste.get("Øyvind Nerbråten")
			.map(_.avdeling)
			.filter(_ != "BMC")
			.getOrElse("BEKK")
```

- Støtter også eksplisitt pattern matching

```scala
	val avdeling: String =
		ansatteliste.get("Øyvind Nerbråten").map(_.avdeling) match {
			case Some("BMC") => "Bekk Management Consulting"
			case Some(x) => x
			case None => "BEKK"
		}
```

---

# Option - Either
 ---
- Noen ganger holder det ikke å kun vite at en feil oppsto; vi trenger noen ganger også å vite årsaken.

---

# Option - Either
 ---
- Noen ganger holder det ikke å kun vite at en feil oppsto; vi trenger noen ganger også å vite årsaken.

- **Either** har på samme måte som Option kun to muligheter, men denne gangen har begge en verdi.

```scala
	sealed trait Either[+E, +A]
	case class Left[+E](value: E) extends Either[E, Nothing]
	case class Right[+A](value: A) extends Either[Nothing, A]
```

- Av konvensjon er Left forbeholdt feilsituasjoner.

---





<!-- Currying -->
# Currying
 ---
---

# Currying
 ---
- Å skrive en funksjon slik at den kan kalles som en "chain" av flere funksjoner.
---

# Currying
 ---
- Å skrive en funksjon slik at den kan kalles som en "chain" av flere funksjoner.

- Å skrive om en funksjon som tar inn flere argumenter til en funksjon som tar inn ett argument og returnerer en funksjon som tar inn neste argument, osv...
---

# Currying
 ---
- Å skrive en funksjon slik at den kan kalles som en "chain" av flere funksjoner.

- Å skrive om en funksjon som tar inn flere argumenter til en funksjon som tar inn ett argument og returnerer en funksjon som tar inn neste argument, osv...

```ERLANG

  within_range(Hi) ->
    fun(Lo) ->
      fun(Num) ->
        (Num &#60; Hi) and (Num >= Lo)
      end
    end.

  ((within_range(10))(3))(7). &#37;&#37; true

```
---

# Currying
 ---
- Å skrive en funksjon slik at den kan kalles som en "chain" av flere funksjoner.

- Å skrive om en funksjon som tar inn flere argumenter til en funksjon som tar inn ett argument og returnerer en funksjon som tar inn neste argument, osv...

```ERLANG

  within_range(Hi) ->
    fun(Lo) ->
      fun(Num) ->
        (Num &#60; Hi) and (Num >= Lo)
      end
    end.

  ((within_range(10))(3))(7). &#37;&#37; true

```

 - Bruker closures og lexical scope
---

# Currying
 ---
- Å skrive en funksjon slik at den kan kalles som en "chain" av flere funksjoner.

- Å skrive om en funksjon som tar inn flere argumenter til en funksjon som tar inn ett argument og returnerer en funksjon som tar inn neste argument, osv...

```ERLANG

  within_range(Hi) ->
    fun(Lo) ->
      fun(Num) ->
        (Num &#60; Hi) and (Num >= Lo)
      end
    end.

  ((within_range(10))(3))(7). &#37;&#37; true

```

 - Bruker closures og lexical scope

 - Partial application

```ERLANG

  within_range(10)  &#37;&#37; &#35;Fun&#60;...>

```
---

# Currying
 ---

 - Språk hvor alle funksjoner er "curried functions" (Haskell, SML, F# ...)
---

# Currying
 ---

 - Språk hvor alle funksjoner er "curried functions" (Haskell, SML, F# ...)

```SML

  fun withinRange hi =>
    fn lo =>
      fn num =>
        num &#60;= hi andalso num >= lo

```

---

# Currying
 ---

 - Språk hvor alle funksjoner er "curried functions" (Haskell, SML, F# ...)

```SML

  fun withinRange hi =>
    fn lo =>
      fn num =>
        num &#60;= hi andalso num >= lo

```

```SML

  // Syntactic sugar:

  fun withinRange hi lo num =>
    num &#60;= hi andalso num >= lo

```
---

# Currying
 ---

 - Språk hvor alle funksjoner er "curried functions" (Haskell, SML, F# ...)

```SML

  fun withinRange hi =>
    fn lo =>
      fn num =>
        num &#60;= hi andalso num >= lo

```

```SML

  // Syntactic sugar:

  fun withinRange hi lo num =>
    num &#60;= hi andalso num >= lo

  withinRange 5 4 3 // false

```
---

# Currying
 ---
 - Currying og partial application eksempel

```SML

  fun zip xs ys =
    case (xs,ys) of
        ([],[]) => []
      | (x::xs’,y::ys’) => (x,y) :: (zip xs’ ys’)
      | _ => raise Empty

  fun range i j =
    if i > j then [] else i :: range (i+1) j

  val countup = range 1

  fun add_numbers liste = zip (countup (length liste)) liste

```
---



<!-- List comprehensions -->

# List comprehensions
 ---

---

# List comprehensions
 ---



    </textarea>
    <div id="slideshow"></div>
  </body>
</html>